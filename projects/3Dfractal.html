<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive 3D Fractal Visualization</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #000000, #32174d, #191970);
      font-family: Arial, sans-serif;
    }
    #container {
      width: 100vw;
      height: 100vh;
    }
    .ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(50, 23, 77, 0.9);
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .ui label {
      font-weight: bold;
      color: #fff;
    }
    .ui select, .ui input[type="number"], .ui input[type="checkbox"] {
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      background: #191970;
      color: #fff;
    }
    #info {
      margin-top: 10px;
      font-size: 14px;
      color: #fff;
      max-width: 200px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="ui">
    <label for="fractal-select">Select Fractal:</label>
    <select id="fractal-select">
      <option value="menger">Menger Sponge</option>
      <option value="mandelbulb">Mandelbulb</option>
    </select>
    <div id="menger-controls" style="display: none;">
      <label for="level-input">Level (1-5):</label>
      <input type="number" id="level-input" min="1" max="5" value="2">
      <label for="gradient-select">Color Gradient:</label>
      <select id="gradient-select">
        <option value="purple-blue">Purple to Blue</option>
        <option value="red-yellow">Red to Yellow</option>
        <option value="green-cyan">Green to Cyan</option>
      </select>
    </div>
    <div id="mandelbulb-controls" style="display: none;">
      <label for="power-input">Power (2-10):</label>
      <input type="number" id="power-input" min="2" max="10" value="8">
    </div>
    <div>
      <input type="checkbox" id="auto-rotate">
      <label for="auto-rotate">Auto-rotate</label>
    </div>
    <div id="info"></div>
  </div>

  <!-- Load Three.js and OrbitControls from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Three.js Scene Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(2, 2, 2);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('container').appendChild(renderer.domElement);

    // Basic Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Soft ambient light
    scene.add(ambientLight);

    // OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Mandelbulb Shader Plane
    const planeGeometry = new THREE.PlaneGeometry(10, 10); // Large enough to cover view
    const planeMaterial = new THREE.ShaderMaterial({
      uniforms: {
        power: { value: 8.0 },
        cameraPosition: { value: new THREE.Vector3() },
        time: { value: 0.0 }
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vWorldPosition;
        void main() {
          vUv = uv;
          vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float power;
        uniform vec3 cameraPosition;
        uniform float time;
        varying vec2 vUv;
        varying vec3 vWorldPosition;

        #define MAX_ITER 20
        #define BAILOUT 2.0
        #define MAX_STEPS 100
        #define MIN_DIST 0.001
        #define MAX_DIST 10.0

        float DE(vec3 p) {
          vec3 z = p;
          float dr = 1.0;
          float r = 0.0;
          for (int i = 0; i < MAX_ITER; i++) {
            r = length(z);
            if (r > BAILOUT) break;
            float theta = acos(z.z / r);
            float phi = atan(z.y, z.x);
            dr = pow(r, power - 1.0) * power * dr + 1.0;
            float zr = pow(r, power);
            theta = theta * power;
            phi = phi * power;
            z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
            z += p;
          }
          return 0.5 * log(r) * r / dr;
        }

        void main() {
          vec3 rayOrigin = cameraPosition;
          vec3 rayDir = normalize(vWorldPosition - cameraPosition);
          float totalDistance = 0.0;
          vec3 color = vec3(0.0);

          for (int step = 0; step < MAX_STEPS; step++) {
            vec3 p = rayOrigin + totalDistance * rayDir;
            float distance = DE(p);
            totalDistance += distance;
            if (distance < MIN_DIST) {
              color = vec3(1.0, 0.3 + 0.2 * sin(time), 0.5 * float(step) / float(MAX_STEPS));
              break;
            }
            if (totalDistance > MAX_DIST) {
              color = vec3(0.0);
              break;
            }
          }
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      side: THREE.FrontSide
    });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    camera.add(plane);
    plane.position.z = -1;
    plane.visible = false;

    let currentFractal = null;

    // Menger Sponge Generation
    function generateMengerSponge(level, gradient) {
      const size = Math.pow(3, level);
      const positions = [];
      for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
          for (let k = 0; k < size; k++) {
            let include = true;
            for (let m = 0; m < level; m++) {
              const im = Math.floor(i / Math.pow(3, m)) % 3;
              const jm = Math.floor(j / Math.pow(3, m)) % 3;
              const km = Math.floor(k / Math.pow(3, m)) % 3;
              const count = (im === 1 ? 1 : 0) + (jm === 1 ? 1 : 0) + (km === 1 ? 1 : 0);
              if (count >= 2) {
                include = false;
                break;
              }
            }
            if (include) {
              positions.push([i, j, k]);
            }
          }
        }
      }
      const cubeSize = 1 / size;
      const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      const gradientColors = {
        'purple-blue': [0xff00ff, 0x00ffff],
        'red-yellow': [0xff0000, 0xffff00],
        'green-cyan': [0x00ff00, 0x00ffff]
      };
      const [color1, color2] = gradientColors[gradient];
      const material = new THREE.MeshPhongMaterial({
        vertexColors: true,
        shininess: 50,
        specular: 0x000000 // Reduced specular for less reflection
      });
      const mesh = new THREE.InstancedMesh(geometry, material, positions.length);
      const matrix = new THREE.Matrix4();
      const color = new THREE.Color();
      positions.forEach((pos, index) => {
        const [i, j, k] = pos;
        const x = (i + 0.5) / size - 0.5;
        const y = (j + 0.5) / size - 0.5;
        const z = (k + 0.5) / size - 0.5;
        matrix.setPosition(x, y, z);
        mesh.setMatrixAt(index, matrix);
        if (i === 0 || j === 0 || k === 0 || i === size - 1 || j === size - 1 || k === size - 1) {
          color.set(0x000000); // Black edges
        } else {
          color.setHSL((i + j + k) / (3 * size), 1.0, 0.5);
          color.lerpColors(new THREE.Color(color1), new THREE.Color(color2), (i + j + k) / (3 * size));
        }
        mesh.setColorAt(index, color);
      });
      mesh.scale.set(2, 2, 2); // Scale for visibility
      return mesh;
    }

    // Set Fractal Function with Camera Reset
    function setFractal(type) {
      if (currentFractal) {
        scene.remove(currentFractal);
      }
      if (type === 'menger') {
        plane.visible = false;
        const level = Math.min(Math.max(parseInt(document.getElementById('level-input').value), 1), 5);
        const gradient = document.getElementById('gradient-select').value;
        const mesh = generateMengerSponge(level, gradient);
        scene.add(mesh);
        currentFractal = mesh;
        document.getElementById('info').textContent = "The Menger Sponge is a 3D fractal curve, a 3D analog of the Sierpinski carpet.";
      } else if (type === 'mandelbulb') {
        plane.visible = true;
        currentFractal = plane;
        document.getElementById('info').textContent = "The Mandelbulb is a 3D fractal constructed by Daniel White and Paul Nylander in 2009 using spherical coordinates.";
      }
      // Reset camera position and target
      camera.position.set(2, 2, 2);
      controls.target.set(0, 0, 0);
      controls.update();
    }

    // Event Listeners
    document.getElementById('fractal-select').addEventListener('change', (e) => {
      const type = e.target.value;
      setFractal(type);
      document.getElementById('menger-controls').style.display = type === 'menger' ? 'block' : 'none';
      document.getElementById('mandelbulb-controls').style.display = type === 'mandelbulb' ? 'block' : 'none';
    });

    document.getElementById('level-input').addEventListener('change', (e) => {
      if (document.getElementById('fractal-select').value === 'menger') {
        setFractal('menger');
      }
    });

    document.getElementById('gradient-select').addEventListener('change', (e) => {
      if (document.getElementById('fractal-select').value === 'menger') {
        setFractal('menger');
      }
    });

    document.getElementById('power-input').addEventListener('change', (e) => {
      const power = Math.min(Math.max(parseFloat(e.target.value), 2), 10);
      planeMaterial.uniforms.power.value = power;
    });

    // Window Resize Handler
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initial Setup
    setFractal('menger');
    document.getElementById('menger-controls').style.display = 'block';

    // Animation Loop with Optional Auto-Rotation
    let time = 0;
    const autoRotateCheckbox = document.getElementById('auto-rotate');
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      time += 0.01;
      planeMaterial.uniforms.time.value = time;
      planeMaterial.uniforms.cameraPosition.value.copy(camera.position);
      if (autoRotateCheckbox.checked && currentFractal && document.getElementById('fractal-select').value === 'menger') {
        currentFractal.rotation.y += 0.005;
      }
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>